<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dinic's Algorithm Visualizer</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <!-- Header Section -->
        <header class="header">
            <h1 class="title">
                <span class="title-gradient">Dinic's Algorithm</span>
                <span class="title-sub">Visualizer</span>
            </h1>
            <p class="subtitle">Maximum Flow Problem ‚Ä¢ O(V¬≤E) Time Complexity</p>
        </header>

        <!-- Main Canvas Section -->
        <div class="canvas-container">
            <canvas id="graphCanvas" width="1000" height="600"></canvas>
            <div class="canvas-overlay" id="canvasOverlay">
                <div class="overlay-message">Click Play to Start</div>
            </div>
        </div>

        <!-- Statistics Dashboard -->
        <div class="stats-grid">
            <div class="stat-card stat-flow">
                <div class="stat-icon">üíß</div>
                <div class="stat-content">
                    <div class="stat-label">Maximum Flow</div>
                    <div class="stat-value" id="maxFlowValue">0</div>
                </div>
                <div class="stat-sparkle"></div>
            </div>

            <div class="stat-card stat-phase">
                <div class="stat-icon">‚ö°</div>
                <div class="stat-content">
                    <div class="stat-label">Current Phase</div>
                    <div class="stat-value stat-phase-text" id="currentPhase">Ready to Start</div>
                </div>
                <div class="stat-sparkle"></div>
            </div>

            <div class="stat-card stat-step">
                <div class="stat-icon">üìä</div>
                <div class="stat-content">
                    <div class="stat-label">Progress</div>
                    <div class="stat-value" id="stepValue">0 / 9</div>
                </div>
                <div class="stat-sparkle"></div>
            </div>

            <div class="stat-card stat-iterations">
                <div class="stat-icon">üîÑ</div>
                <div class="stat-content">
                    <div class="stat-label">Iterations</div>
                    <div class="stat-value" id="iterationValue">0</div>
                </div>
                <div class="stat-sparkle"></div>
            </div>
        </div>

        <!-- Control Panel -->
        <div class="control-panel">
            <div class="control-section">
                <h3 class="control-title">
                    <span class="control-icon">üéÆ</span>
                    Playback Controls
                </h3>
                <div class="button-group">
                    <button class="btn btn-primary" id="playBtn">
                        <span class="btn-icon" id="playIcon">‚ñ∂</span>
                        <span id="playText">Play</span>
                    </button>
                    <button class="btn btn-secondary" id="stepBtn">
                        <span class="btn-icon">‚è≠</span>
                        <span>Step</span>
                    </button>
                    <button class="btn btn-danger" id="resetBtn">
                        <span class="btn-icon">‚Üª</span>
                        <span>Reset</span>
                    </button>
                </div>
            </div>

            <div class="control-section">
                <h3 class="control-title">
                    <span class="control-icon">‚öôÔ∏è</span>
                    Speed Control
                </h3>
                <div class="speed-control">
                    <label class="speed-label">
                        <span>üêå</span>
                        <span>Slow</span>
                    </label>
                    <input type="range" id="speedSlider" min="200" max="2000" step="200" value="1000" class="speed-slider">
                    <label class="speed-label">
                        <span>Fast</span>
                        <span>üöÄ</span>
                    </label>
                    <div class="speed-value" id="speedValue">1.2x</div>
                </div>
            </div>

            <div class="control-section">
                <h3 class="control-title">
                    <span class="control-icon">üé®</span>
                    Visualization Options
                </h3>
                <div class="toggle-group">
                    <label class="toggle-item">
                        <input type="checkbox" id="showLabels" checked>
                        <span class="toggle-text">Show Edge Labels</span>
                    </label>
                    <label class="toggle-item">
                        <input type="checkbox" id="showAnimation" checked>
                        <span class="toggle-text">Smooth Animations</span>
                    </label>
                    <label class="toggle-item">
                        <input type="checkbox" id="showLevels" checked>
                        <span class="toggle-text">Highlight Levels</span>
                    </label>
                </div>
            </div>
        </div>

        <!-- Algorithm Information Panel -->
        <div class="info-panel">
            <div class="info-header">
                <h3 class="info-title">
                    <span class="info-icon">üìö</span>
                    Algorithm Steps
                </h3>
            </div>
            <div class="info-content">
                <div class="step-list">
                    <div class="step-item" data-step="1">
                        <div class="step-number">1</div>
                        <div class="step-details">
                            <div class="step-name">Build Level Graph</div>
                            <div class="step-desc">Use BFS to assign levels to each node from source</div>
                        </div>
                    </div>
                    <div class="step-item" data-step="2">
                        <div class="step-number">2</div>
                        <div class="step-details">
                            <div class="step-name">Find Blocking Flow</div>
                            <div class="step-desc">Use DFS to find augmenting paths and push maximum flow</div>
                        </div>
                    </div>
                    <div class="step-item" data-step="3">
                        <div class="step-number">3</div>
                        <div class="step-details">
                            <div class="step-name">Update Residual Graph</div>
                            <div class="step-desc">Update edge capacities and flows based on blocking flow</div>
                        </div>
                    </div>
                    <div class="step-item" data-step="4">
                        <div class="step-number">4</div>
                        <div class="step-details">
                            <div class="step-name">Repeat</div>
                            <div class="step-desc">Continue until no augmenting path exists in level graph</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Legend -->
        <div class="legend">
            <h3 class="legend-title">Legend</h3>
            <div class="legend-items">
                <div class="legend-item">
                    <div class="legend-dot legend-source"></div>
                    <span>Source Node</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot legend-sink"></div>
                    <span>Sink Node</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot legend-normal"></div>
                    <span>Normal Node</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot legend-level"></div>
                    <span>Level Graph Node</span>
                </div>
                <div class="legend-item">
                    <div class="legend-line legend-edge"></div>
                    <span>Edge</span>
                </div>
                <div class="legend-item">
                    <div class="legend-line legend-flow"></div>
                    <span>Flow Path</span>
                </div>
            </div>
        </div>

        <!-- Footer -->
        <footer class="footer">
            <p>Interactive Visualization of Dinic's Maximum Flow Algorithm</p>
            <p class="footer-note">Developed with ‚ù§Ô∏è for Algorithm Enthusiasts</p>
        </footer>
    </div>

    <style>
/* ==================== GLOBAL STYLES ==================== */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
    color: #fff;
    overflow-x: hidden;
    min-height: 100vh;
}

.container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 20px;
}

/* ==================== HEADER ==================== */
.header {
    text-align: center;
    margin-bottom: 30px;
    animation: fadeInDown 0.8s ease-out;
}

.title {
    font-size: 3.5rem;
    font-weight: 900;
    margin-bottom: 10px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
}

.title-gradient {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    animation: shimmer 3s infinite;
    filter: drop-shadow(0 0 20px rgba(102, 126, 234, 0.5));
}

.title-sub {
    font-size: 2.5rem;
    color: #a78bfa;
    font-weight: 700;
}

.subtitle {
    font-size: 1.2rem;
    color: #cbd5e1;
    font-weight: 300;
    letter-spacing: 2px;
}

/* ==================== CANVAS SECTION ==================== */
.canvas-container {
    position: relative;
    background: rgba(15, 23, 42, 0.6);
    border-radius: 20px;
    padding: 20px;
    margin-bottom: 30px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    border: 2px solid rgba(102, 126, 234, 0.3);
    backdrop-filter: blur(10px);
    animation: fadeIn 1s ease-out;
    overflow: hidden;
}

#graphCanvas {
    width: 100%;
    height: auto;
    border-radius: 12px;
    display: block;
}

.canvas-overlay {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
    transition: opacity 0.3s;
}

.canvas-overlay.hidden {
    opacity: 0;
}

.overlay-message {
    background: rgba(102, 126, 234, 0.9);
    padding: 20px 40px;
    border-radius: 50px;
    font-size: 1.5rem;
    font-weight: 600;
    box-shadow: 0 10px 30px rgba(102, 126, 234, 0.5);
    animation: pulse 2s infinite;
}

/* ==================== STATISTICS GRID ==================== */
.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 20px;
    margin-bottom: 30px;
    animation: fadeInUp 1s ease-out 0.2s both;
}

.stat-card {
    background: linear-gradient(135deg, rgba(30, 41, 59, 0.8), rgba(51, 65, 85, 0.6));
    padding: 25px;
    border-radius: 16px;
    display: flex;
    align-items: center;
    gap: 20px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.1);
    position: relative;
    overflow: hidden;
    transition: transform 0.3s, box-shadow 0.3s;
}

.stat-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 15px 40px rgba(102, 126, 234, 0.4);
}

.stat-sparkle {
    position: absolute;
    top: -50%;
    right: -50%;
    width: 200%;
    height: 200%;
    background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, transparent 70%);
    animation: rotate 10s linear infinite;
    pointer-events: none;
}

.stat-icon {
    font-size: 2.5rem;
    filter: drop-shadow(0 0 10px currentColor);
}

.stat-content {
    flex: 1;
}

.stat-label {
    font-size: 0.9rem;
    color: #94a3b8;
    margin-bottom: 5px;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.stat-value {
    font-size: 2rem;
    font-weight: 700;
    color: #fff;
}

.stat-phase-text {
    font-size: 1.2rem;
}

.stat-flow { border-left: 4px solid #10b981; }
.stat-phase { border-left: 4px solid #3b82f6; }
.stat-step { border-left: 4px solid #a78bfa; }
.stat-iterations { border-left: 4px solid #f59e0b; }

/* ==================== CONTROL PANEL ==================== */
.control-panel {
    background: rgba(30, 41, 59, 0.8);
    padding: 30px;
    border-radius: 20px;
    margin-bottom: 30px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
    border: 2px solid rgba(102, 126, 234, 0.2);
    backdrop-filter: blur(10px);
    animation: fadeInUp 1s ease-out 0.4s both;
}

.control-section {
    margin-bottom: 30px;
}

.control-section:last-child {
    margin-bottom: 0;
}

.control-title {
    font-size: 1.3rem;
    margin-bottom: 15px;
    color: #e2e8f0;
    display: flex;
    align-items: center;
    gap: 10px;
}

.control-icon {
    font-size: 1.5rem;
}

.button-group {
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
}

.btn {
    padding: 15px 30px;
    border: none;
    border-radius: 12px;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 10px;
    transition: all 0.3s;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    position: relative;
    overflow: hidden;
}

.btn::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.2);
    transform: translate(-50%, -50%);
    transition: width 0.6s, height 0.6s;
}

.btn:hover::before {
    width: 300px;
    height: 300px;
}

.btn:active {
    transform: scale(0.95);
}

.btn-icon {
    font-size: 1.2rem;
}

.btn-primary {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
}

.btn-primary:hover {
    box-shadow: 0 8px 25px rgba(102, 126, 234, 0.5);
}

.btn-secondary {
    background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
    color: white;
}

.btn-secondary:hover {
    box-shadow: 0 8px 25px rgba(59, 130, 246, 0.5);
}

.btn-danger {
    background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
    color: white;
}

.btn-danger:hover {
    box-shadow: 0 8px 25px rgba(239, 68, 68, 0.5);
}

.btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* ==================== SPEED CONTROL ==================== */
.speed-control {
    display: flex;
    align-items: center;
    gap: 15px;
    flex-wrap: wrap;
}

.speed-label {
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 0.9rem;
    color: #cbd5e1;
}

.speed-slider {
    flex: 1;
    min-width: 200px;
    height: 8px;
    border-radius: 5px;
    background: linear-gradient(90deg, #3b82f6, #8b5cf6);
    outline: none;
    -webkit-appearance: none;
}

.speed-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: white;
    cursor: pointer;
    box-shadow: 0 0 10px rgba(139, 92, 246, 0.8);
}

.speed-slider::-moz-range-thumb {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: white;
    cursor: pointer;
    box-shadow: 0 0 10px rgba(139, 92, 246, 0.8);
    border: none;
}

.speed-value {
    background: rgba(139, 92, 246, 0.3);
    padding: 8px 16px;
    border-radius: 8px;
    font-weight: 600;
    color: #a78bfa;
    min-width: 60px;
    text-align: center;
}

/* ==================== TOGGLE GROUP ==================== */
.toggle-group {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.toggle-item {
    display: flex;
    align-items: center;
    gap: 10px;
    cursor: pointer;
    padding: 10px;
    border-radius: 8px;
    transition: background 0.3s;
}

.toggle-item:hover {
    background: rgba(255, 255, 255, 0.05);
}

.toggle-item input[type="checkbox"] {
    width: 20px;
    height: 20px;
    cursor: pointer;
    accent-color: #8b5cf6;
}

.toggle-text {
    color: #cbd5e1;
    font-size: 0.95rem;
}

/* ==================== INFO PANEL ==================== */
.info-panel {
    background: rgba(30, 41, 59, 0.8);
    border-radius: 20px;
    margin-bottom: 30px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
    border: 2px solid rgba(102, 126, 234, 0.2);
    backdrop-filter: blur(10px);
    overflow: hidden;
    animation: fadeInUp 1s ease-out 0.6s both;
}

.info-header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    padding: 20px 30px;
}

.info-title {
    font-size: 1.5rem;
    display: flex;
    align-items: center;
    gap: 10px;
    color: white;
}

.info-icon {
    font-size: 1.8rem;
}

.info-content {
    padding: 30px;
}

.step-list {
    display: grid;
    gap: 20px;
}

.step-item {
    display: flex;
    gap: 20px;
    padding: 20px;
    background: rgba(51, 65, 85, 0.4);
    border-radius: 12px;
    border-left: 4px solid #8b5cf6;
    transition: all 0.3s;
}

.step-item:hover {
    background: rgba(51, 65, 85, 0.6);
    transform: translateX(10px);
}

.step-number {
    width: 50px;
    height: 50px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.5rem;
    font-weight: 700;
    flex-shrink: 0;
    box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
}

.step-details {
    flex: 1;
}

.step-name {
    font-size: 1.2rem;
    font-weight: 600;
    margin-bottom: 5px;
    color: #e2e8f0;
}

.step-desc {
    color: #94a3b8;
    line-height: 1.6;
}

/* ==================== LEGEND ==================== */
.legend {
    background: rgba(30, 41, 59, 0.8);
    padding: 20px 30px;
    border-radius: 16px;
    margin-bottom: 20px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.1);
    animation: fadeInUp 1s ease-out 0.8s both;
}

.legend-title {
    font-size: 1.2rem;
    margin-bottom: 15px;
    color: #e2e8f0;
}

.legend-items {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 10px;
    color: #cbd5e1;
    font-size: 0.9rem;
}

.legend-dot {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    box-shadow: 0 0 10px currentColor;
}

.legend-source { background: #10b981; }
.legend-sink { background: #ef4444; }
.legend-normal { background: #64748b; }
.legend-level { background: #3b82f6; }

.legend-line {
    width: 30px;
    height: 3px;
    border-radius: 2px;
}

.legend-edge { background: #64748b; }
.legend-flow { background: #22c55e; }

/* ==================== FOOTER ==================== */
.footer {
    text-align: center;
    padding: 30px 0;
    color: #94a3b8;
    font-size: 0.9rem;
    animation: fadeIn 1s ease-out 1s both;
}

.footer-note {
    margin-top: 10px;
    font-size: 0.85rem;
    color: #64748b;
}

/* ==================== ANIMATIONS ==================== */
@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes fadeInDown {
    from {
        opacity: 0;
        transform: translateY(-30px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes fadeInUp {
    from {
        opacity: 0;
        transform: translateY(30px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}

@keyframes shimmer {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}

@keyframes rotate {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

/* ==================== RESPONSIVE ==================== */
@media (max-width: 768px) {
    .title {
        font-size: 2.5rem;
    }
    
    .title-sub {
        font-size: 1.8rem;
    }
    
    .button-group {
        flex-direction: column;
    }
    
    .btn {
        width: 100%;
        justify-content: center;
    }
    
    .speed-control {
        flex-direction: column;
        align-items: stretch;
    }
    
    .legend-items {
        flex-direction: column;
    }
}
    </style>

    <script>
// ==================== GRAPH DATA ====================
const graphData = {
    nodes: [
        { id: 0, x: 150, y: 300, label: 'S', type: 'source' },
        { id: 1, x: 350, y: 180, label: '1', type: 'normal' },
        { id: 2, x: 350, y: 420, label: '2', type: 'normal' },
        { id: 3, x: 600, y: 180, label: '3', type: 'normal' },
        { id: 4, x: 600, y: 420, label: '4', type: 'normal' },
        { id: 5, x: 850, y: 300, label: 'T', type: 'sink' }
    ],
    edges: [
        { from: 0, to: 1, capacity: 10, flow: 0 },
        { from: 0, to: 2, capacity: 10, flow: 0 },
        { from: 1, to: 2, capacity: 2, flow: 0 },
        { from: 1, to: 3, capacity: 4, flow: 0 },
        { from: 1, to: 4, capacity: 8, flow: 0 },
        { from: 2, to: 4, capacity: 9, flow: 0 },
        { from: 3, to: 5, capacity: 10, flow: 0 },
        { from: 4, to: 3, capacity: 6, flow: 0 },
        { from: 4, to: 5, capacity: 10, flow: 0 }
    ]
};

// ==================== STATE ====================
let state = {
    isPlaying: false,
    speed: 1000,
    step: 0,
    maxFlow: 0,
    iterations: 0,
    currentPhase: 'Ready to Start',
    levelGraph: [],
    highlightedEdges: [],
    flowPath: [],
    showLabels: true,
    showAnimation: true,
    showLevels: true,
    graph: JSON.parse(JSON.stringify(graphData))
};

// ==================== DOM ELEMENTS ====================
const canvas = document.getElementById('graphCanvas');
const ctx = canvas.getContext('2d');
const playBtn = document.getElementById('playBtn');
const stepBtn = document.getElementById('stepBtn');
const resetBtn = document.getElementById('resetBtn');
const speedSlider = document.getElementById('speedSlider');
const speedValue = document.getElementById('speedValue');
const maxFlowValue = document.getElementById('maxFlowValue');
const currentPhase = document.getElementById('currentPhase');
const stepValue = document.getElementById('stepValue');
const iterationValue = document.getElementById('iterationValue');
const playIcon = document.getElementById('playIcon');
const playText = document.getElementById('playText');
const canvasOverlay = document.getElementById('canvasOverlay');
const showLabelsCheckbox = document.getElementById('showLabels');
const showAnimationCheckbox = document.getElementById('showAnimation');
const showLevelsCheckbox = document.getElementById('showLevels');

// ==================== DRAWING FUNCTIONS ====================
function drawGraph() {
    const width = canvas.width;
    const height = canvas.height;
    
    // Clear with gradient
    const gradient = ctx.createLinearGradient(0, 0, width, height);
    gradient.addColorStop(0, '#0f172a');
    gradient.addColorStop(0.5, '#1e1b4b');
    gradient.addColorStop(1, '#1e293b');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);
    
    // Draw grid pattern
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
    ctx.lineWidth = 1;
    for (let i = 0; i < width; i += 50) {
        ctx.beginPath();
        ctx.moveTo(i, 0);
        ctx.lineTo(i, height);
        ctx.stroke();
    }
    for (let i = 0; i < height; i += 50) {
        ctx.beginPath();
        ctx.moveTo(0, i);
        ctx.lineTo(width, i);
        ctx.stroke();
    }
    
    // Draw edges
    state.graph.edges.forEach((edge, idx) => {
        drawEdge(edge, idx);
    });
    
    // Draw nodes
    state.graph.nodes.forEach((node) => {
        drawNode(node);
    });
}

function drawEdge(edge, idx) {
    const fromNode = state.graph.nodes[edge.from];
    const toNode = state.graph.nodes[edge.to];
    
    const isHighlighted = state.highlightedEdges.includes(idx);
    const isInPath = state.flowPath.some(p => p.from === edge.from && p.to === edge.to);
    
    // Calculate angle and positions
    const angle = Math.atan2(toNode.y - fromNode.y, toNode.x - fromNode.x);
    const startX = fromNode.x + Math.cos(angle) * 35;
    const startY = fromNode.y + Math.sin(angle) * 35;
    const endX = toNode.x - Math.cos(angle) * 35;
    const endY = toNode.y - Math.sin(angle) * 35;
    
    // Draw edge line
    ctx.beginPath();
    ctx.moveTo(startX, startY);
    ctx.lineTo(endX, endY);
    
    if (isInPath) {
        ctx.strokeStyle = '#22c55e';
        ctx.lineWidth = 5;
        ctx.shadowColor = '#22c55e';
        ctx.shadowBlur = 20;
    } else if (isHighlighted) {
        ctx.strokeStyle = '#3b82f6';
        ctx.lineWidth = 4;
        ctx.shadowColor = '#3b82f6';
        ctx.shadowBlur = 15;
    } else if (edge.flow > 0) {
        const flowRatio = edge.flow / edge.capacity;
        ctx.strokeStyle = `rgba(139, 92, 246, ${0.5 + flowRatio * 0.5})`;
        ctx.lineWidth = 2 + flowRatio * 2;
        ctx.shadowColor = '#8b5cf6';
        ctx.shadowBlur = 10;
    } else {
        ctx.strokeStyle = '#475569';
        ctx.lineWidth = 2;
        ctx.shadowBlur = 0;
    }
    
    ctx.stroke();
    ctx.shadowBlur = 0;
    
    // Draw arrow head
    const arrowSize = 12;
    ctx.beginPath();
    ctx.moveTo(endX, endY);
    ctx.lineTo(
        endX - arrowSize * Math.cos(angle - Math.PI / 6),
        endY - arrowSize * Math.sin(angle - Math.PI / 6)
    );
    ctx.moveTo(endX, endY);
    ctx.lineTo(
        endX - arrowSize * Math.cos(angle + Math.PI / 6),
        endY - arrowSize * Math.sin(angle + Math.PI / 6)
    );
    ctx.stroke();
    
    // Draw edge label
    if (state.showLabels) {
        const midX = (fromNode.x + toNode.x) / 2;
        const midY = (fromNode.y + toNode.y) / 2;
        const offsetX = -Math.sin(angle) * 25;
        const offsetY = Math.cos(angle) * 25;
        
        // Label background
        ctx.fillStyle = '#1e293b';
        ctx.strokeStyle = isInPath ? '#22c55e' : (isHighlighted ? '#3b82f6' : '#334155');
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.roundRect(midX + offsetX - 28, midY + offsetY - 14, 56, 28, 6);
        ctx.fill();
        ctx.stroke();
        
        // Label text
        ctx.font = 'bold 13px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = edge.flow > 0 ? '#a78bfa' : '#cbd5e1';
        ctx.fillText(`${edge.flow}/${edge.capacity}`, midX + offsetX, midY + offsetY);
    }
}

function drawNode(node) {
    const isInLevel = state.showLevels && state.levelGraph.includes(node.id);
    
    // Node glow
    if (state.showAnimation) {
        ctx.beginPath();
        ctx.arc(node.x, node.y, 45, 0, Math.PI * 2);
        const glowGradient = ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, 45);
        
        if (node.type === 'source') {
            glowGradient.addColorStop(0, 'rgba(16, 185, 129, 0.4)');
            glowGradient.addColorStop(1, 'rgba(16, 185, 129, 0)');
        } else if (node.type === 'sink') {
            glowGradient.addColorStop(0, 'rgba(239, 68, 68, 0.4)');
            glowGradient.addColorStop(1, 'rgba(239, 68, 68, 0)');
        } else if (isInLevel) {
            glowGradient.addColorStop(0, 'rgba(59, 130, 246, 0.4)');
            glowGradient.addColorStop(1, 'rgba(59, 130, 246, 0)');
        } else {
            glowGradient.addColorStop(0, 'rgba(100, 116, 139, 0.3)');
            glowGradient.addColorStop(1, 'rgba(100, 116, 139, 0)');
        }
        
        ctx.fillStyle = glowGradient;
        ctx.fill();
    }
    
    // Node circle
    ctx.beginPath();
    ctx.arc(node.x, node.y, 35, 0, Math.PI * 2);
    
    if (node.type === 'source') {
        const sourceGrad = ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, 35);
        sourceGrad.addColorStop(0, '#34d399');
        sourceGrad.addColorStop(1, '#10b981');
        ctx.fillStyle = sourceGrad;
    } else if (node.type === 'sink') {
        const sinkGrad = ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, 35);
        sinkGrad.addColorStop(0, '#f87171');
        sinkGrad.addColorStop(1, '#ef4444');
        ctx.fillStyle = sinkGrad;
    } else if (isInLevel) {
        const levelGrad = ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, 35);
        levelGrad.addColorStop(0, '#60a5fa');
        levelGrad.addColorStop(1, '#3b82f6');
        ctx.fillStyle = levelGrad;
    } else {
        const normalGrad = ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, 35);
        normalGrad.addColorStop(0, '#64748b');
        normalGrad.addColorStop(1, '#475569');
        ctx.fillStyle = normalGrad;
    }
    
    ctx.fill();
    
    // Node border
    ctx.strokeStyle = '#1e293b';
    ctx.lineWidth = 3;
    ctx.stroke();
    
    // Inner highlight
    ctx.beginPath();
    ctx.arc(node.x, node.y, 32, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
    ctx.lineWidth = 1;
    ctx.stroke();
    
    // Node label
    ctx.font = 'bold 22px sans-serif';
    ctx.fillStyle = '#ffffff';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(node.label, node.x, node.y);
}

// ==================== ALGORITHM SIMULATION ====================
function simulateDinicStep() {
    if (state.step === 0) {
        state.currentPhase = 'Building Level Graph (BFS)';
        state.levelGraph = [0, 1, 2];
        state.highlightedEdges = [0, 1];
        updateStepIndicator(1);
    } else if (state.step === 1) {
        state.levelGraph = [0, 1, 2, 3, 4, 5];
        state.highlightedEdges = [3, 4, 5, 6, 8];
        state.currentPhase = 'Level Graph Complete';
    } else if (state.step === 2) {
        state.currentPhase = 'Finding Blocking Flow (DFS)';
        state.flowPath = [{ from: 0, to: 1 }, { from: 1, to: 3 }, { from: 3, to: 5 }];
        state.highlightedEdges = [0, 3, 6];
        updateStepIndicator(2);
    } else if (state.step === 3) {
        pushFlow([
            { from: 0, to: 1 },
            { from: 1, to: 3 },
            { from: 3, to: 5 }
        ], 4);
        state.flowPath = [];
        state.currentPhase = 'Flow Pushed: +4 units';
        state.iterations++;
        updateStepIndicator(3);
    } else if (state.step === 4) {
        state.flowPath = [{ from: 0, to: 2 }, { from: 2, to: 4 }, { from: 4, to: 5 }];
        state.highlightedEdges = [1, 5, 8];
        state.currentPhase = 'Finding Next Augmenting Path';
    } else if (state.step === 5) {
        pushFlow([
            { from: 0, to: 2 },
            { from: 2, to: 4 },
            { from: 4, to: 5 }
        ], 9);
        state.flowPath = [];
        state.currentPhase = 'Flow Pushed: +9 units';
        state.iterations++;
    } else if (state.step === 6) {
        state.flowPath = [
            { from: 0, to: 1 },
            { from: 1, to: 4 },
            { from: 4, to: 3 },
            { from: 3, to: 5 }
        ];
        state.highlightedEdges = [0, 4, 7, 6];
        state.currentPhase = 'Complex Path Discovered';
    } else if (state.step === 7) {
        pushFlow([
            { from: 0, to: 1 },
            { from: 1, to: 4 },
            { from: 4, to: 3 },
            { from: 3, to: 5 }
        ], 6);
        state.flowPath = [];
        state.currentPhase = 'Flow Pushed: +6 units';
        state.iterations++;
    } else if (state.step === 8) {
        state.currentPhase = '‚ú® Algorithm Complete! Maximum Flow Found';
        state.highlightedEdges = [];
        state.levelGraph = [];
        state.isPlaying = false;
        updatePlayButton();
        canvasOverlay.classList.remove('hidden');
        document.querySelector('.overlay-message').textContent = 'Maximum Flow: ' + state.maxFlow;
        updateStepIndicator(4);
    }
    
    state.step++;
    updateUI();
    drawGraph();
}

function pushFlow(path, amount) {
    path.forEach(({ from, to }) => {
        const edge = state.graph.edges.find(e => e.from === from && e.to === to);
        if (edge) {
            edge.flow += amount;
        }
    });
    state.maxFlow += amount;
}

function updateStepIndicator(stepNum) {
    document.querySelectorAll('.step-item').forEach(item => {
        item.style.background = 'rgba(51, 65, 85, 0.4)';
        item.style.borderLeftColor = '#8b5cf6';
    });
    
    if (stepNum > 0 && stepNum <= 4) {
        const stepItem = document.querySelector(`.step-item[data-step="${stepNum}"]`);
        if (stepItem) {
            stepItem.style.background = 'rgba(139, 92, 246, 0.3)';
            stepItem.style.borderLeftColor = '#a78bfa';
        }
    }
}

// ==================== UI UPDATES ====================
function updateUI() {
    maxFlowValue.textContent = state.maxFlow;
    currentPhase.textContent = state.currentPhase;
    stepValue.textContent = `${state.step} / 9`;
    iterationValue.textContent = state.iterations;
}

function updatePlayButton() {
    if (state.isPlaying) {
        playIcon.textContent = '‚è∏';
        playText.textContent = 'Pause';
        playBtn.classList.add('playing');
        canvasOverlay.classList.add('hidden');
    } else {
        playIcon.textContent = '‚ñ∂';
        playText.textContent = 'Play';
        playBtn.classList.remove('playing');
    }
}

// ==================== EVENT HANDLERS ====================
playBtn.addEventListener('click', () => {
    if (state.step >= 9) return;
    state.isPlaying = !state.isPlaying;
    updatePlayButton();
    if (state.isPlaying) {
        runAlgorithm();
    }
});

stepBtn.addEventListener('click', () => {
    if (state.step >= 9) return;
    state.isPlaying = false;
    updatePlayButton();
    simulateDinicStep();
});

resetBtn.addEventListener('click', () => {
    state.isPlaying = false;
    state.step = 0;
    state.maxFlow = 0;
    state.iterations = 0;
    state.currentPhase = 'Ready to Start';
    state.levelGraph = [];
    state.highlightedEdges = [];
    state.flowPath = [];
    state.graph = JSON.parse(JSON.stringify(graphData));
    updatePlayButton();
    updateUI();
    drawGraph();
    canvasOverlay.classList.remove('hidden');
    document.querySelector('.overlay-message').textContent = 'Click Play to Start';
    updateStepIndicator(0);
});

speedSlider.addEventListener('input', (e) => {
    state.speed = parseInt(e.target.value);
    const speedMultiplier = (2200 - state.speed) / 1000;
    speedValue.textContent = speedMultiplier.toFixed(1) + 'x';
});

showLabelsCheckbox.addEventListener('change', (e) => {
    state.showLabels = e.target.checked;
    drawGraph();
});

showAnimationCheckbox.addEventListener('change', (e) => {
    state.showAnimation = e.target.checked;
    drawGraph();
});

showLevelsCheckbox.addEventListener('change', (e) => {
    state.showLevels = e.target.checked;
    drawGraph();
});

// ==================== ANIMATION LOOP ====================
function runAlgorithm() {
    if (!state.isPlaying || state.step >= 9) {
        state.isPlaying = false;
        updatePlayButton();
        return;
    }
    
    simulateDinicStep();
    
    setTimeout(() => {
        runAlgorithm();
    }, state.speed);
}

// ==================== INITIALIZATION ====================
function init() {
    drawGraph();
    updateUI();
    
    // Add canvas animation on load
    canvas.style.opacity = '0';
    setTimeout(() => {
        canvas.style.transition = 'opacity 1s';
        canvas.style.opacity = '1';
    }, 100);
}

// Start the application
init();
    </script>
</body>
</html>
